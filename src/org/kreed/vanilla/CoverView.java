/*
 * Copyright (C) 2010, 2011 Christopher Eby <kreed@kreed.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package org.kreed.vanilla;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.widget.Scroller;

/**
 * Displays a flingable/draggable View of cover art/song info images
 * generated by CoverBitmap.
 */
public final class CoverView extends View implements Handler.Callback {
	/**
	 * The system-provided snap velocity, used as a threshold for detecting
	 * flings.
	 */
	private static int sSnapVelocity = -1;
	/**
	 * The Handler with which to do background work. Will be null until
	 * setupHandler is called.
	 */
	private Handler mHandler;
	/**
	 * A handler running on the UI thread, for UI operations.
	 */
	private final Handler mUiHandler = new Handler(this);
	/**
	 * How to render cover art and metadata. One of
	 * CoverBitmap.STYLE_*
	 */
	private int mCoverStyle;
	/**
	 * Interface to respond to CoverView motion actions.
	 */
	public interface Callback {
		/**
		 * Called after the view has scrolled to the next or previous cover.
		 *
		 * @param delta -1 for the previous cover, 1 for the next.
		 */
		public void shiftCurrentSong(int delta);
		/**
		 * Called when the user has swiped up on the view.
		 */
		public void upSwipe();
		/**
		 * Called when the user had swiped down on the view.
		 */
		public void downSwipe();
	}
	/**
	 * The instance of the callback.
	 */
	private Callback mCallback;
	/**
	 * The current set of songs: 0 = previous, 1 = current, and 2 = next.
	 */
	private final Song[] mSongs = new Song[3];
	/**
	 * The covers for the current songs: 0 = previous, 1 = current, and 2 = next.
	 */
	private final Bitmap[] mBitmaps = new Bitmap[3];
	/**
	 * Cache of cover bitmaps generated for songs. The song ids are the keys.
	 */
	private final Cache<Bitmap> mBitmapCache = new Cache<Bitmap>(8);
	/**
	 * Cover art to use when a song has no cover art in no info display styles.
	 */
	private Bitmap mDefaultCover;
	/**
	 * Computes scroll animations.
	 */
	private final Scroller mScroller;
	/**
	 * Computes scroll velocity to detect flings.
	 */
	private VelocityTracker mVelocityTracker;
	/**
	 * The x coordinate of the last touch down or move event.
	 */
	private float mLastMotionX;
	/**
	 * The y coordinate of the last touch down or move event.
	 */
	private float mLastMotionY;
	/**
	 * The x coordinate of the last touch down event.
	 */
	private float mStartX;
	/**
	 * The y coordinate of the last touch down event.
	 */
	private float mStartY;
	/**
	 * The index of the cover that is being scrolled to during a fling
	 * animation, or -1 if the cover is the active (middle) cover.
	 */
	private int mTentativeCover = -1;
	/**
	 * Ignore the next pointer up event, for long presses.
	 */
	private boolean mIgnoreNextUp;
	/**
	 * If true, querySongs was called before the view initialized and should
	 * be called when initialization finishes.
	 */
	private boolean mPendingQuery;
	/**
	 * If true, calls to invalidate() will do nothing. We use this so we can
	 * only invalidate the dirty rect during scrolling.
	 */
	private boolean mSuppressInvalidate;

	/**
	 * Constructor intended to be called by inflating from XML.
	 */
	public CoverView(Context context, AttributeSet attributes)
	{
		super(context, attributes);

		mScroller = new Scroller(context);

		if (sSnapVelocity == -1)
			sSnapVelocity = ViewConfiguration.get(context).getScaledMinimumFlingVelocity();
	}

	/**
	 * Setup the Handler and callback. This must be called before
	 * the CoverView is used.
	 *
	 * @param looper A looper created on a worker thread.
	 * @param callback The callback for nextSong/previousSong
	 * @param style One of CoverBitmap.STYLE_*
	 */
	public void setup(Looper looper, Callback callback, int style)
	{
		mHandler = new Handler(looper, this);
		mCallback = callback;
		mCoverStyle = style;
	}

	/**
	 * Reset the scroll position to its default state.
	 */
	private void resetScroll()
	{
		if (!mScroller.isFinished())
			mScroller.abortAnimation();
		scrollTo(getWidth(), 0);
	}

	@Override
	protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight)
	{
		if (mPendingQuery && width != 0 && height != 0) {
			mPendingQuery = false;
			querySongs(PlaybackService.get(getContext()));
		}
	}

	/**
	 * Paint the cover art views to the canvas.
	 */
	@Override
	protected void onDraw(Canvas canvas)
	{
		int width = getWidth();
		int height = getHeight();
		int x = 0;
		int scrollX = getScrollX();

		canvas.drawColor(Color.BLACK);

		for (Bitmap bitmap : mBitmaps) {
			if (bitmap != null && scrollX + width > x && scrollX < x + width) {
				int xOffset = (width - bitmap.getWidth()) / 2;
				int yOffset = (height - bitmap.getHeight()) / 2;
				canvas.drawBitmap(bitmap, x + xOffset, yOffset, null);
			}
			x += width;
		}
	}

	/**
	 * Scrolls the view when dragged. Animates a fling to one of the three covers
	 * when finished. The cover flung to will be either the nearest cover, or if
	 * the fling is fast enough, the cover in the direction of the fling.
	 *
	 * Also performs a click on the view when it is tapped without dragging.
	 */
	@Override
	public boolean onTouchEvent(MotionEvent ev)
	{
		if (mVelocityTracker == null)
			mVelocityTracker = VelocityTracker.obtain();
		mVelocityTracker.addMovement(ev);

		float x = ev.getX();
		float y = ev.getY();
		int scrollX = getScrollX();
		int width = getWidth();

		switch (ev.getAction()) {
		case MotionEvent.ACTION_DOWN:
			if (!mScroller.isFinished())
				mScroller.abortAnimation();

			mStartX = x;
			mStartY = y;
			mLastMotionX = x;
			mLastMotionY = y;

			mUiHandler.sendEmptyMessageDelayed(MSG_LONG_CLICK, ViewConfiguration.getLongPressTimeout());
			break;
		case MotionEvent.ACTION_MOVE: {
			float deltaX = mLastMotionX - x;
			float deltaY = mLastMotionY - y;

			if (Math.abs(deltaX) > Math.abs(deltaY)) {
				if (deltaX < 0) {
					int availableToScroll = scrollX - (mSongs[0] == null ? width : 0);
					if (availableToScroll > 0)
						scrollBy(Math.max(-availableToScroll, (int)deltaX), 0);
				} else if (deltaX > 0) {
					int availableToScroll = width * 2 - scrollX;
					if (availableToScroll > 0)
						scrollBy(Math.min(availableToScroll, (int)deltaX), 0);
				}
			}

			mLastMotionX = x;
			mLastMotionY = y;
			break;
		}
		case MotionEvent.ACTION_UP: {
			mUiHandler.removeMessages(MSG_LONG_CLICK);

			VelocityTracker velocityTracker = mVelocityTracker;
			velocityTracker.computeCurrentVelocity(250);
			int velocityX = (int) velocityTracker.getXVelocity();
			int velocityY = (int) velocityTracker.getYVelocity();
			int mvx = Math.abs(velocityX);
			int mvy = Math.abs(velocityY);

			int min = mSongs[0] == null ? 1 : 0;
			int max = 2;

			int whichCover = 1;

			if (Math.abs(mStartX - x) + Math.abs(mStartY - y) < 10) {
				// A long press was performed and thus the normal action should
				// not be executed.
				if (mIgnoreNextUp)
					mIgnoreNextUp = false;
				else
					performClick();
				whichCover = 1;
			} else if (mvx > sSnapVelocity || mvy > sSnapVelocity) {
				if (mvy > mvx) {
					if (velocityY > 0)
						mCallback.downSwipe();
					else
						mCallback.upSwipe();
				} else {
					if (velocityX > 0)
						whichCover = min;
					else
						whichCover = max;
				}
			} else {
				int nearestCover = (scrollX + width / 2) / width;
				whichCover = Math.max(min, Math.min(nearestCover, max));
			}

			int newX = whichCover * width;
			int delta = newX - scrollX;
			mScroller.startScroll(scrollX, 0, delta, 0, Math.abs(delta) * 2);
			if (whichCover != 1)
				mTentativeCover = whichCover;

			mUiHandler.sendEmptyMessage(MSG_SCROLL);

			if (mVelocityTracker != null) {
				mVelocityTracker.recycle();
				mVelocityTracker = null;
			}

			break;
		}
		}
		return true;
	}

	/**
	 * Generates a bitmap for the given song if the cache does not contain one
	 * for it, or moves the bitmap to the top of the cache if it does.
	 *
	 * @param i The position of the song in mSongs.
	 */
	private void generateBitmap(int i)
	{
		Song song = mSongs[i];
		if (song == null || song.id == -1)
			return;

		Bitmap reuse = mBitmapCache.discardOldest();
		if (reuse == mDefaultCover)
			reuse = null;

		int style = mCoverStyle;
		Context context = getContext();
		Bitmap cover = song.getCover(context);
		int width = getWidth();
		int height = getHeight();

		Bitmap bitmap;
		if (cover == null && (style == CoverBitmap.STYLE_NO_INFO || style == CoverBitmap.STYLE_NO_INFO_ZOOMED)) {
			if (mDefaultCover == null)
				mDefaultCover = CoverBitmap.generateDefaultCover(width, height);
			bitmap = mDefaultCover;
		} else {
			bitmap = CoverBitmap.createBitmap(context, style, cover, song, width, height, reuse);
		}

		mBitmaps[i] = bitmap;
		mBitmapCache.put(song.id, bitmap);
		postInvalidate();
	}

	/**
	 * Set the Song at position <code>i</code> to <code>song</code>, generating
	 * the bitmap for it in the background if needed.
	 */
	public void setSong(int i, Song song)
	{
		mSongs[i] = song;
		if (song == null) {
			mBitmaps[i] = null;
		} else {
			Bitmap bitmap = mBitmapCache.get(song.id);
			if (bitmap != null) {
				mBitmaps[i] = bitmap;
				mBitmapCache.touch(song.id);
			} else {
				mBitmaps[i] = null;
				mHandler.sendMessage(mHandler.obtainMessage(MSG_GENERATE_BITMAP, i, 0));
			}
		}
	}

	/**
	 * Query all songs. Must be called on the UI thread.
	 *
	 * @param service Service to query from.
	 */
	public void querySongs(PlaybackService service)
	{
		if (getWidth() == 0 || getHeight() == 0) {
			mPendingQuery = true;
			return;
		}

		mHandler.removeMessages(MSG_GENERATE_BITMAP);
		setSong(1, service.getSong(0));
		setSong(2, service.getSong(1));
		setSong(0, service.getSong(-1));
		resetScroll();
		invalidate();
	}

	/**
	 * Call {@link CoverView#generateBitmap(int)} for the song at the given index.
	 *
	 * obj must be the Song to generate a bitmap for.
	 */
	private static final int MSG_GENERATE_BITMAP = 0;
	/**
	 * Perform a long click.
	 *
	 * @see View#performLongClick()
	 */
	private static final int MSG_LONG_CLICK = 2;
	/**
	 * Update position for fling scroll animation and, when it is finished,
	 * notify PlaybackService that the user has requested a track change and
	 * update the cover art views. Will resend message until scrolling is
	 * finished.
	 */
	private static final int MSG_SCROLL = 3;

	@Override
	public boolean handleMessage(Message message)
	{
		switch (message.what) {
		case MSG_GENERATE_BITMAP:
			generateBitmap(message.arg1);
			break;
		case MSG_LONG_CLICK:
			if (Math.abs(mStartX - mLastMotionX) + Math.abs(mStartY - mLastMotionY) < 10) {
				mIgnoreNextUp = true;
				performLongClick();
			}
			break;
		case MSG_SCROLL:
			if (mScroller.computeScrollOffset()) {
				// scrollTo calls invalidate(), however, we want to invalidate
				// only the region where the covers are drawn, so we need to
				// suppress this call.
				mSuppressInvalidate = true;
				scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
				mSuppressInvalidate = false;

				invalidateCovers();
				mUiHandler.sendEmptyMessage(MSG_SCROLL);
			} else if (mTentativeCover != -1) {
				mCallback.shiftCurrentSong(mTentativeCover - 1);
				mTentativeCover = -1;
				resetScroll();
			}
			break;
		default:
			return false;
		}

		return true;
	}

	@Override
	protected void onMeasure(int widthSpec, int heightSpec)
	{
		// This implementation only tries to handle two cases: use in the
		// FullPlaybackActivity, where we want to fill the whole screen,
		// and use in the MiniPlaybackActivity, where we want to be square.

		int width = View.MeasureSpec.getSize(widthSpec);
		int height = View.MeasureSpec.getSize(heightSpec);

		if (View.MeasureSpec.getMode(widthSpec) == View.MeasureSpec.EXACTLY
			&& View.MeasureSpec.getMode(heightSpec) == View.MeasureSpec.EXACTLY) {
			// FullPlaybackActivity: fill screen
			setMeasuredDimension(width, height);
		} else {
			// MiniPlaybackActivity: be square
			int size = Math.min(width, height);
			setMeasuredDimension(size, size);
		}
	}

	/**
	 * Overridden to allow redraws to be suppressed.
	 */
	@Override
	public void invalidate()
	{
		if (!mSuppressInvalidate)
			super.invalidate();
	}

	/**
	 * Call {@link View#invalidate(int,int,int,int)} with the area
	 * containing the visible cover(s).
	 */
	public void invalidateCovers()
	{
		int width = getWidth();
		int height = getHeight();
		int scrollX = getScrollX();
		int x = 0;
		int maxHeight = 0;

		for (Bitmap bitmap : mBitmaps) {
			if (bitmap != null && scrollX + width > x && scrollX < x + width) {
				int bitmapHeight = bitmap.getHeight();
				if (bitmapHeight > maxHeight) {
					maxHeight = bitmapHeight;
				}
			}
			x += width;
		}

		int offset = (height - maxHeight) / 2;
		invalidate(scrollX, offset, scrollX + width, height - offset);
	}
}
